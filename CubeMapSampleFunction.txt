int w = imageWidth
int h = imageHeight

func computeRadius(size,the) -> r{

	r = size / (2*cos(the));
	return r;
	
}
func sphericalr2cartesian(the,phi,r)-> x,y,z{


	x = r* sin(the)*cos(phi);

	y = r*sin(the)*sin(phi);

	z = r*cos(the);

	return x,y,z;


}
func convert_cube_uv_to_xyz(float u, float v)-> x,y,z
	// convert range 0 to 1 to -1 to 1
	float uc = 2.0f * u - 1.0f;
	float vc = 2.0f * v - 1.0f;
	switch (index)
	{
	case 0: *x =  1.0f; *y =    vc; *z =   -uc; break;	// POSITIVE X
	case 1: *x = -1.0f; *y =    vc; *z =    uc; break;	// NEGATIVE X
	case 2: *x =    uc; *y =  1.0f; *z =   -vc; break;	// POSITIVE Y
	case 3: *x =    uc; *y = -1.0f; *z =    vc; break;	// NEGATIVE Y
	case 4: *x =    uc; *y =    vc; *z =  1.0f; break;	// POSITIVE Z
	case 5: *x =   -uc; *y =    vc; *z = -1.0f; break;	// NEGATIVE Z
	}

	return x,y,z;
}

func convert_xyz_to_cube_uv(float x, float y, float z)-> u,v,index{
	float absX = fabs(x);
	float absY = fabs(y);
	float absZ = fabs(z);

	int isXPositive = x > 0 ? 1 : 0;
	int isYPositive = y > 0 ? 1 : 0;
	int isZPositive = z > 0 ? 1 : 0;

	float maxAxis, uc, vc;

	// POSITIVE X
	if (isXPositive && absX >= absY && absX >= absZ) {
	// u (0 to 1) goes from +z to -z
	// v (0 to 1) goes from -y to +y
	maxAxis = absX;
	uc = -z;
	vc = y;
	*index = 0;
	}
	// NEGATIVE X
	if (!isXPositive && absX >= absY && absX >= absZ) {
	// u (0 to 1) goes from -z to +z
	// v (0 to 1) goes from -y to +y
	maxAxis = absX;
	uc = z;
	vc = y;
	*index = 1;
	}
	// POSITIVE Y
	if (isYPositive && absY >= absX && absY >= absZ) {
	// u (0 to 1) goes from -x to +x
	// v (0 to 1) goes from +z to -z
	maxAxis = absY;
	uc = x;
	vc = -z;
	*index = 2;
	}
	// NEGATIVE Y
	if (!isYPositive && absY >= absX && absY >= absZ) {
	// u (0 to 1) goes from -x to +x
	// v (0 to 1) goes from -z to +z
	maxAxis = absY;
	uc = x;
	vc = z;
	*index = 3;
	}
	// POSITIVE Z
	if (isZPositive && absZ >= absX && absZ >= absY) {
	// u (0 to 1) goes from -x to +x
	// v (0 to 1) goes from -y to +y
	maxAxis = absZ;
	uc = x;
	vc = y;
	*index = 4;
	}
	// NEGATIVE Z
	if (!isZPositive && absZ >= absX && absZ >= absY) {
	// u (0 to 1) goes from +x to -x
	// v (0 to 1) goes from -y to +y
	maxAxis = absZ;
	uc = -x;
	vc = y;
	*index = 5;
	}

	// Convert range from -1 to 1 to 0 to 1
	*u = 0.5f * (uc / maxAxis + 1.0f);
	*v = 0.5f * (vc / maxAxis + 1.0f);

	return u,v,index;
}

func findPixel(int index, float u, float v) -> n,m{
	int tileWidth = w / 3;
	int tileHeight = h /2;
	
	n = tileWidth*index + u;
	m = tileHeight*index + v;
	
	return n,m;
}

func main(i,j,the,phi) -> n,m{

	r = computeRadius(sizeOfCube,the);
	
	x,y,z = sphericalr2cartesian(the,phi,r);
	
	u,v,index = convert_xyz_to_cube_uv(x,y,z);

	n,m = findPixel(index,u,v);
	return n,m;
}




Referenceï¼›https://en.wikipedia.org/wiki/Cube_mapping
